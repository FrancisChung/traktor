"""
    Module for modifying Native Instruments' Traktor 2 database.
    Allows for auto-generation of cue points and basic searching of songs.
    Written by Peter Sobot, July 16, 2011, at #sehackday #4.
    http://github.com/psobot/traktor

    (Requires an Echo Nest Remix API key: http://code.google.com/p/echo-nest-remix/)
"""

import numpy, sys, os, math, re
import echonest.audio as audio
from echonest import modify
from echonest.selection import *
from echonest.sorting import *
from lxml import etree

class TraktorDB:
    """
    Class for modifying Native Instruments' Traktor 2 database.
    Attempts to find the user's Traktor database file, parses it, and extracts tracks.
    Main, magical feature: allows auto-generation of cuepoints via the Echo Nest API.    
    """

    def __init__(self, path=None):
        """
        Generate new instance of TraktorDB.
        Automatically tries to guess the location of collection.nml if none is provided.
        """
        if path:
            if os.path.exists(path):
                self.path = path
            else:
                raise Exception("Provided database file not found! (at %s)" % path)
        else:
            #   Try-to-find-database-file mode
            #   For example, mine's at: "~/Documents/Native Instruments/Traktor 2.0.3/collection.nml"
            #   Start reading at ~ and try to recurse down there.
            self.path = os.path.expanduser("~/Documents/Native Instruments/")
            if os.path.exists(self.path):
                traktorFolder = None
                for folder in os.listdir(self.path):         #   Returns subfolders in order
                    if folder.startswith("Traktor"):    #   Therefore latest version of Traktor will always be first
                        traktorFolder = folder
                if traktorFolder:
                    self.path += traktorFolder + "/collection.nml"
                    if not os.path.exists(self.path):
                        raise Exception("collections.nml file not found!" )
                else:
                    raise Exception("Traktor preferences folder not found!")
            else:
                raise Exception("Native Instruments preferences folder not found!")

        l = open(self.path, "r")
        self.original = l.read()
        l.seek(0)
        self.header = l.readline()
        l.close()

        self.data = etree.parse(self.path)

    def _checkConsistency(self):
        """
        Checks if the Traktor database has changed since it was opened.
        If the file is changed at any point after the instance of TraktorDB is created, this will raise an exception.
        """
        l = open(self.path, "r")
        current_xml = l.read()
        l.close()
        if current_xml != self.original:
            raise Exception("Traktor database has changed!")
        else:
            return True

    def save(self):
        """
        Saves the working copy of the database back to collection.nml.
        Checks for consistency first, and preserves consistency across multiple saves of the same object.
        """
        self._checkConsistency()
        xml = self.header + etree.tostring(self.data)
        l = open(self.path, "w")
        l.write(xml)
        l.close()
        self.original = xml

    def _justASCII(self, string):
        try:
            string.decode('ascii')
        except:
            return False
        return True

    def generateCues(self, track, replace=False):
        """
        Automatically generates cuepoints for a given track.
        Track can be an lxml element (returned from TraktorDB.getTrack...) or a track name.
        Takes an optional "replace" parameter, that deletes the existing cuepoints and replaces them with the autogenerated ones. (Even if there are less!)

        Uses the Echo Nest Remix API to perform its magic.
        Returns a list of the new CUE_V2 elements.
        """
        self._checkConsistency()
        if not isinstance(track, etree._Element):
            track = self.getTracksByName(track)
            if len(track) > 1:
                raise Exception("Multiple tracks with that name!")
            else:
                track = track[0]
        if not track.get("AUDIO_ID"):
            raise Exception("Track has not been analyzed by Traktor!")

        if not replace and len(track.findall("CUE_V2")) > 1:   #   ignore the usual Autogrid cue
            raise Exception("Track already has cues!")

        #   TODO: Fix this to work on more than Mac
        location =  track.find("LOCATION")
        localpath = "/Volumes/" + location.get("VOLUME") + location.get("DIR").replace("/:", "/") + location.get("FILE")
        
        if not self._justASCII(localpath):
            print "Error: non-ASCII file paths currently break this program. This path didn't work:", localpath
            return track.findall("CUE_V2")

        song = audio.LocalAudioFile(localpath)
        os.unlink(song.convertedfile)

        offset = 0  #   used when the echonest thinks a song starts with a rest

        #   TODO: refactor this to return early
        #   TODO: refine this offset system. Kinda hackish and not very reliable. 
        if song.analysis.beats:
            if track.findall("CUE_V2") and track.findall("CUE_V2")[0].get("NAME") == "AutoGrid":
                #   make use of Traktor's autogrid start point if it exists
                if (song.analysis.beats[0].start * 1000) < float(track.findall("CUE_V2")[0].get("START")):
                    offset = (float(track.findall("CUE_V2")[0].get("START"))/1000 - song.analysis.beats[0].start)
                    print "EchoNest thinks that the song starts with a rest. Offsetting by %s." % offset        # remove second cue then!!! 2nd cue is redundant
                for cue in track.findall("CUE_V2")[1:]:     #   Leave first cue, grid cue
                    track.remove(cue)
            else:
                for cue in track.findall("CUE_V2"):
                    track.remove(cue)

            #   Look ma, audio analysis!

            potentialCues = []
            
            print "Overall analysis confidence: %s" % (song.analysis.time_signature['confidence'])
            if song.analysis.time_signature['confidence'] < 0.5:
                print "Analysis not very confident - song may have bad cuepoints."

            firstbeats = song.analysis.beats[::song.analysis.time_signature['value']]   #   grab every nth beat
            beatlength = 60.0/song.analysis.tempo['value']

            #   Start by iterating through sections...
            for i, section in enumerate(song.analysis.sections):
                closestBeat = None
                closestDistance = song.analysis.duration
                for beat in firstbeats:   
                    if abs(beat.start - section.start) < closestDistance:
                        closestBeat = beat
                        closestDistance = abs(beat.start - section.start)
                if closestBeat.start - offset > 0:
                    potentialCues.append({"start": closestBeat.start + offset, "confidence": closestBeat.confidence})

            #   If we have more cues than hotcue spots available, then choose the top 7 most confident.
            if len(potentialCues) > 7:
                potentialCues = sorted(potentialCues, key=lambda k: k['confidence'])
                potentialCues = potentialCues[:7]
                potentialCues = sorted(potentialCues, key=lambda k: k['start'])
            
            for i, cue in enumerate(potentialCues):
                print "Confidence of cue %s: %s" % (i, cue['confidence'])

            for i, cue in enumerate(potentialCues):
                cueElement = etree.Element("CUE_V2")
                #<CUE_V2 NAME="AutoGrid" DISPL_ORDER="0" TYPE="4" START="74.359565676842521" LEN="0" REPEATS="-1" HOTCUE="0"></CUE_V2>
                cueElement.set("NAME", "Section " + str(i + 1))
                cueElement.set("DISPL_ORDER", str(0))
                cueElement.set("TYPE", str(0))
                cueElement.set("LEN", str(0))
                cueElement.set("REPEATS", str(-1))
                cueElement.set("HOTCUE", str(i + 1))
                cueElement.set("START", str(cue['start'] * 1000))
                track.append(cueElement)

        return track.findall("CUE_V2")

    def getTrackByPath(self, path):
        """
        Fetches track entry from the database, given a (relative or absolute) file path for the song.
        Returns the one track that matches, or raises an exception if not found.
        """
        #   Currently only works most-reliably on Mac...
        filename = os.path.basename(path)
        results = self.data.findall("COLLECTION/ENTRY/LOCATION[@FILE='%s']" % filename)
        if len(results) > 1:
            pathComponents = re.search("/Volumes/(.+?)/(.+?)/%s" % filename, os.path.abspath(path))
            print "[DEBUG] pathComponents:", pathComponents
            if pathComponents:
                pathComponents = pathComponents.groups()
                volume = pathComponents[0]
                traktorDir = pathComponents[1].replace("/", "/:")

                result = self.data.find("COLLECTION/ENTRY/LOCATION[@DIR='%s']" % traktorDir)
                if not result:
                    raise Exception("Track with path not found!")
                else:
                    return result
            else:
                #   Gotta fix this to work on more than external mac drives. Really...
                raise Exception("Multiple results for filename, and filepath parsing failed!")
        elif len(results):
            return results[0].getparent()
        else:
            raise Exception("Track with path '%s' not found!" % path)

    def getTracksByName(self, name):
        """
        Fetches all track entries from the database with a given name.
        Returns a list of tracks that fully match the name, or raises an exception if not found.
        """
        #   Quickly check for full name with the fast method...
        r = self.data.findall("COLLECTION/ENTRY[@TITLE='%s']" % name)
        if r:
            return r
        else:
            raise Exception("Tracks with name '%s' not found!" % name)

    def getAvailableTracks(self):
        """
        Fetches all track entries that could possibly be processed by the generateCues() method.
        Tracks must have been analyzed by Traktor and and have only one cuepoint (AutoGrid) to be eligible.
        Returns a list of all the tracks; raises an exception if no tracks found.
        """
        #   Quickly check for full name with the fast method...
        r = self.data.xpath("COLLECTION/ENTRY[@AUDIO_ID][count(CUE_V2) = 1]")   #Make sure track is not already in the "Processed" playlist
        if r:
            processed = db.data.findall("/PLAYLISTS/NODE[@TYPE='FOLDER']/SUBNODES/NODE[@TYPE='PLAYLIST'][@NAME='Auto-Cued Tracks']/PLAYLIST/ENTRY")
            if processed:
                for track in processed:
                    pk = track.find("PRIMARYKEY").get("KEY")
                    lp = re.search("(.+?)(/.+/:)(.+?)", pk)
                    volume = lp.groups()[0]
                    directory = lp.groups()[1]
                    filename = lp.groups()[2]
                    for t in r:
                        if t.find("LOCATION").get("FILE") == filename or t.find("LOCATION").get("DIR") == directory:
                            r.remove(t)
            return r
        else:
            raise Exception("No tracks available to add cues for!")

    def prettyPrintTracks(self, tracklist=None):
        """
        Pretty-prints all tracks in a given list of tracks.
        If no tracks given, then it prints all the available tracks.
        """
        if not tracklist:
            tracklist = self.getAvailableTracks()
        for track in tracklist:
            playtime = track.find("INFO").get("PLAYTIME")
            if playtime:
                playtime = int(playtime)
                secs = playtime % 60
                mins = int(playtime/60)
            else:
                mins = 0
                secs = 0
            print "\"%s\" by %s (%d:%02d)" % (track.get("TITLE"), track.get("ARTIST"), mins, secs )

    def searchForTracksByName(self, name):
        """
        Fetches all track entries with names that contain a given string. (Search!)
        Returns a list of all the tracks, or raises an exception if no tracks are found.
        """
        r = self.data.xpath("COLLECTION/ENTRY[contains(@TITLE, '%s')" % name)
        if r:
            return r
        else:
            raise Exception("Tracks containing '%s' not found!" % name)

    def getTracksByArtist(self, name):
        """
        Fetches all track entries by a given artist.
        Returns a list of all the tracks, or raises an exception if no tracks are found.
        """
        r = self.data.findall("COLLECTION/ENTRY[@ARTIST='%s']" % name)
        if r:
            return r
        else:
            raise Exception("Tracks with artist '%s' not found!" % name)

    def processAllTracks(self):
        """
        Automatically generates cues for every single eligible track.
        This method uses a ridiculous amount of bandwidth, takes a ridiculous amount of time, and is probably the only genuinely useful application of the entire module.
        """
        for track in self.getAvailableTracks():
            print "Processing track:"
            self.prettyPrintTracks([track])
            self.generateCues(track)
            self.addToPlaylist(track)
            self.save()

    def addToPlaylist(self, track):
        """
        Adds track entry to "Auto-Cued Tracks" playlist.
        Method still very hacky.
        """
        #playlist must already exist - TODO: Write code to generate playlist
        playlist = self.data.find("/PLAYLISTS/NODE[@TYPE='FOLDER']/SUBNODES/NODE[@TYPE='PLAYLIST'][@NAME='Auto-Cued Tracks']/PLAYLIST")
        # <ENTRY><PRIMARYKEY TYPE="TRACK" KEY="Fry HD/:Music/:iTunes/:iTunes Music/:Jamiroquai/:Travelling Without Moving/:01 Virtual Insanity.mp3"></PRIMARYKEY></ENTRY>
        entry = etree.Element("ENTRY")
        primarykey = etree.Element("PRIMARYKEY")
        primarykey.set("TYPE", "TRACK")
        location =  track.find("LOCATION")
        localpath = location.get("VOLUME") + location.get("DIR").replace("/[^:]", "/:") + location.get("FILE")
        primarykey.set("KEY", localpath)
        entry.append(primarykey)
        playlist.append(entry)
        playlist.set("ENTRIES", str(int(playlist.get("ENTRIES")) + 1))


#   Only run this code if invoked, not if imported.
if __name__ == '__main__':
    db = TraktorDB()
